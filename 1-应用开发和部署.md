## 应用开发和部署

#### 使用唯一性标识给镜像打标签

当生成容器镜像时，应当使用唯一性标识来给容器镜像打标签，唯一标识可以更好的标记当次生成的镜像，避免出现多个同名标签但不同的版本镜像被使用的情况。例如多次部署都使用了latest标签的镜像，可能因为拉取和缓存策略导致不同节点使用了不同版本的镜像，从而导致功能上的不一致，在这种情况下，并不能很方便的判断出某个节点部署的是哪一个版本。

唯一标识最好有一定的含义，不仅可以用来区分产物，还可以获取到本次构建的关键信息。比如git提交哈希等关联性比较强的标识。虽然时间戳也是一个唯一性比较强的标识，但是关联性相对较差，如果长度不足，也有一定的几率产生碰撞。可以考虑使用组合型标签，比如使用时间戳，build号，版本号等根据自己的需求来组合生成唯一标识，这样的标签本身就包含了很丰富的信息。

我们不建议单纯使用pipeline的build序号来作为镜像的标签，如果需要更换CI工具或者重建pipeline时，这个序号将会被重置而可能产生重复，除非在构建脚本中加入偏移量。而且不同的CI工具获取这个序号的方法也有所不同，对于迁移并不友好。虽然它的可追溯性看起来较好，但是单纯的Build序号和代码之间并没有直接的关联。

如果不是需要对外公开发布的镜像，并不建议对同一镜像打上多个不同标签。因为绝大部分的情况下，我们只会选用其中一个的标签在所有的地方使用，多个标签的实际意义并不会很大。


**唯一性标识的优点：**

1. 可以准确对应的到源代码具体版本，在溯源时可以对应到特定的提交而不是可能存在的多个提交。

2. 不需要使用SHA256等额外的信息来区分同一标签的不同版本。

**可能存在的缺点：**

1. 一些类型的唯一性标识可读性不是很高，比如git提交哈希。

2. 一些类型的标识受时间影响，不能使用同一命令获得一致结果，需要使用其他的方式来传递给后续阶段，比如时间戳。



**如何实施：**

```
GIT_HASH=$(git rev-parse HEAD)

docker build --rm -t "myapp:${GIT_HASH}" .
```

#### 牲口模式

将需要大量、精心工作来维护的具有特定属性的服务实例（宠物模式），转变为可以被随时销毁和被替换的服务实例组（牲口模式），从而将更多资源和精力投入到更有价值的地方。配合自动化的基础设施，使服务实例以更快的速度演进，也使业务具备更多的弹性去应对市场变化。

为大家所熟知的“无状态”应用，是“牲口模式”的一种实现方式。“牲口模式”不等于“无状态”。

**宠物模式的弊端：**
1. 需要单独管理每一个服务实例，可能是手动安装、调试。
2. 服务实例只能垂直扩展（Scale-Up），昂贵且容易遇到瓶颈。
3. 应用部署笨重，难以自由地升级或者回滚应用，从而阻碍业务频繁变更。
4. 难以及时给服务实例打补丁、升级系统，从而承担不必要的安全风险。
5. 难以避免故障带来的服务失效和可能存在的数据损失的风险。

**牲口模式的收益：**
1. 支持自动故障切换。配合自动化基础设施，无需单独管理每个服务实例，节约管理成本和团队精力。
2. 支持自动水平伸缩（Scale-Out），配合自动化基础设施，从容应对业务峰谷，节约业务成本。
3. 支持随时被销毁或被替换，可以在不影响服务稳定性的前提下部署应用、进行系统升级或者打补丁。 

**如何实施：**
* “无状态”应用
1. API请求之间完全隔离，完成业务所需的数据均由客户端发送的请求提供。
2. 使用客户端Cookie、cache取代服务器端Session。对于一些敏感的临时数据，服务器端可以加密后交由客户端存储，在下个API请求时发回服务器解密使用。
3. 通过锁或者幂等性设计，使得应用能正确、快速、自动地解决对同一份数据的竞争而导致的流程异常、数据不一致等问题。例如，定时任务批量读取数据。

