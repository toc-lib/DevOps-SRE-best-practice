## 应用开发和部署

### 使用唯一性标识给镜像打标签

当生成容器镜像时，应当使用唯一性标识来给容器镜像打标签，唯一标识可以更好的标记当次生成的镜像，避免出现多个同名标签但不同的版本镜像被使用的情况。例如多次部署都使用了latest标签的镜像，可能因为拉取和缓存策略导致不同节点使用了不同版本的镜像，从而导致功能上的不一致，在这种情况下，并不能很方便的判断出某个节点部署的是哪一个版本。

唯一标识最好有一定的含义，不仅可以用来区分产物，还可以获取到本次构建的关键信息。比如git提交哈希等关联性比较强的标识。虽然时间戳也是一个唯一性比较强的标识，但是关联性相对较差，如果长度不足，也有一定的几率产生碰撞。可以考虑使用组合型标签，比如使用时间戳，build号，版本号等根据自己的需求来组合生成唯一标识，这样的标签本身就包含了很丰富的信息。

我们不建议单纯使用pipeline的build序号来作为镜像的标签，如果需要更换CI工具或者重建pipeline时，这个序号将会被重置而可能产生重复，除非在构建脚本中加入偏移量。而且不同的CI工具获取这个序号的方法也有所不同，对于迁移并不友好。虽然它的可追溯性看起来较好，但是单纯的Build序号和代码之间并没有直接的关联。

如果不是需要对外公开发布的镜像，并不建议对同一镜像打上多个不同标签。因为绝大部分的情况下，我们只会选用其中一个的标签在所有的地方使用，多个标签的实际意义并不会很大。


**唯一性标识的优点：**

1. 可以准确对应的到源代码具体版本，在溯源时可以对应到特定的提交而不是可能存在的多个提交。

2. 不需要使用SHA256等额外的信息来区分同一标签的不同版本。

**可能存在的缺点：**

1. 一些类型的唯一性标识可读性不是很高，比如git提交哈希。

2. 一些类型的标识受时间影响，不能使用同一命令获得一致结果，需要使用其他的方式来传递给后续阶段，比如时间戳。



**如何实施：**

```
GIT_HASH=$(git rev-parse HEAD)

docker build --rm -t "myapp:${GIT_HASH}" .
```

### 牲口模式

将需要大量、精心工作来维护的具有特定属性的服务实例（宠物模式），转变为可以被随时销毁和被替换的服务实例组（牲口模式），从而将更多资源和精力投入到更有价值的地方。配合自动化的基础设施，使服务实例以更快的速度演进，也使业务具备更多的弹性去应对市场变化。

为大家所熟知的“无状态”应用，是“牲口模式”的一种实现方式。“牲口模式”不等于“无状态”。

**宠物模式的弊端：**
1. 需要单独管理每一个服务实例，可能是手动安装、调试。
2. 服务实例只能垂直扩展（Scale-Up），昂贵且容易遇到瓶颈。
3. 应用部署笨重，难以自由地升级或者回滚应用，从而阻碍业务频繁变更。
4. 难以及时给服务实例打补丁、升级系统，从而承担不必要的安全风险。
5. 难以避免故障带来的服务失效和可能存在的数据损失的风险。

**牲口模式的收益：**
1. 支持自动故障切换。配合自动化基础设施，无需单独管理每个服务实例，节约管理成本和团队精力。
2. 支持自动水平伸缩（Scale-Out），配合自动化基础设施，从容应对业务峰谷，节约业务成本。
3. 支持随时被销毁或被替换，可以在不影响服务稳定性的前提下部署应用、进行系统升级或者打补丁。 

**如何实施：**
* “无状态”应用
1. API请求之间完全隔离，完成业务所需的数据均由客户端发送的请求提供。
2. 使用客户端Cookie、cache取代服务器端Session。对于一些敏感的临时数据，服务器端可以加密后交由客户端存储，在下个API请求时发回服务器解密使用。
3. 通过锁或者幂等性设计，使得应用能正确、快速、自动地解决对同一份数据的竞争而导致的流程异常、数据不一致等问题。例如，定时任务批量读取数据。


### 减少脚本/工具对环境的依赖

一般情况下，脚本都会或多或少的使用到一些外部工具。而我们的脚本很有可能会运行在不同的环境中，不同环境中提供的工具也会有版本和用法的差异。我们建议尽可能的减少所使用的工具对环境的依赖，尤其是系统不会默认安装的工具。另外在编写脚本的时候，也尽量避免使用只有某些版本才有的语法特性。这些情况都会导致管理脚本有可能出现一些不可预期的结果，我们建议使用容器化工具或者容器化环境管理工具如Batect来替代对应的需求。

**优点：**

1. 环境中只需要安装容器化工具即可。如：docker

    软件构建过程中可能会存在不同的服务需求不同，特别在微服务架构中。如前端使用 nodejs 开发，后端使用 java。则需要在 agent 中安装对应的编译软件，无疑增加了工具数量以及版本的维护成本。使用容器化工具的方式来管理，我们只需要确保 agent 有容器运行时，并将这个 image 做好保存，以后无论是前端还是后端，我们都能通过脚本来运行不同的容器工具如 gradle 镜像，就可以进行软件构建。使用这种方法，容器运行时的版本更新也可以做到一步到位。

2. 使本地运行与在线上环境中运行的软件一致，都是基于同一个 Dockerfile 或者同一个 image

    使用容器化的方式基于同一个 Dockerfile 构建出来的 artifact，我们可以将它运行在本地进行测试，通过后用同样的的 artifact 部署到线上环境。这样我们的安全测试以及业务测试结果都能进行保证。出现问题也可以使用本地的环境进行快速的排查，这样可以在一些权限控制严格，没有线上环境 debug 权限的情况下，进行一个快速的查错。

3. 对新人友好

    容器化的工具使得新人只需要知道进行构建的软件使用方式，不需要再去手动安装，配置工具。新人如果需要更新工具或者版本，可以快速的进行，无需关心每个工具的安装，升级方式，同时也避免了手动操作过程中出现的失误来 block CI 的运行。

4. 升级单个项目的环境变得非常容易

    使用容器化工具的情况下，脚本可以作为一个构建阶段的文档。通过统一的管理可以清除的知道在一个干净的环境中运行了哪些工具来完成构建工作。每个工具的版本信息，来源信息在一个脚本中就可以看到。当有升级需求的时候，可以快速的更改，无需关心工具背后的依赖问题，简单查看工具容器的文档，更改本版号就可以完成升级来进行测试。脚本在版本控制之下，测试失败回滚的代价也极小。

5. 解耦对 CI 工具或 agent 的依赖

    虽然在实际项目中我们更换CI工具的情况极少，但是如果做到使用容器化工具来进行软件的构建，我们的脚本就可以在不同的agent中来运行构建，将极大的减少维护成本，增加 agent 的利用率。不用再去手动维护每个 agent 的配置，只需要有相同的容器运行时配置，即可增强构建阶段的兼容性。由于使用容器，所以在真的发生 CI 工具切换的时候，我们也只需要使新的工具能运行脚本，agent 支持容器运行时，即可开始构建，大大减少了切换工具的额外工作量。

**缺点：**

1. 需要花费更多的流量

    由于在 agent 上没有安装构建所需要的各种软件，只有容器化工具(docker 等)，每次在运行任何的一条命令的时候都需要去容器仓库中获取对应的镜像。这无疑增加了 agent 在流量上的压力。

2. 运行过程需要的时间更长

    由于在 agent 上没有安装构建所需要的各种软件，每当要运行一个 task，都需要在 agent 上启动一个容器去运行对应，那么时间就会变为：下载 image + 启动容器 + task 执行，相比于直接在 agent 上直接运行 task 多出了“下载 image + 启动容器”的时间。

**如何实现：**

例：在容器中运行 terraform

在使用 terraform 时，不同版本之间的 terraform 并不兼容，那么如何保证所有人与 CI 都使用相同的 terraform 版本就是一个非常麻烦的事情。那么如果我们无论在 CI 还是本地都基于 docker 去运行 terraform 就可以解决这个问题。

```shell
#!/usr/bin/env bash

function terraform() {
  docker run --rm -it \
      -v $(pwd):/app -w /app \
      hashicorp/terraform:1.1.4 -c "$@"
}

terraform init
terraform plan && terraform apply
```
